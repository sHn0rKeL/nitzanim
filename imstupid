class Solution:
    def hasSameDigits(self, num_str: str) -> bool:
        str_length = len(num_str)

        # Convert the string to an integer
        current_num = int(num_str)
        last_extracted_digit = 0
        iteration_count = 0
        temp_digit = 0
        new_num_accumulator = 0
        is_valid = False  # Not used later
        initial_digit_count = 0
        num_copy = current_num
        first_digit = 0
        temp_storage = {}  # Not used later
        prev_digit = 0
        num_for_reversal = 0
        reversed_num_length = 0
        zero_padding_count = 0
        zero_count = 0
        reversed_digit = 0
        reversed_num = 0
        is_p0_true = True

        all_digits_equal = True
        
        # 1. Calculate the actual number of digits in the integer value
        while num_copy > 0:
            initial_digit_count = initial_digit_count + 1
            num_copy = num_copy // 10
        num_copy = current_num

        # 2. Handle cases where there were leading zeros (initial_digit_count < str_length)
        if initial_digit_count != str_length:
            is_p0_true = True
            zero_padding_count = str_length - initial_digit_count
            
            if initial_digit_count > 1:
                # Store the most significant digit (which will be the final digit extracted)
                while current_num > 0:
                    first_digit = current_num % 10
                    current_num = current_num // 10
                current_num = num_copy
                
                # Apply the transformation (adjacent digits sum mod 10) for the initial number
                while zero_padding_count > 0:
                    
                    if current_num != num_copy:
                        z = (last_extracted_digit + prev_digit) % 10
                        new_num_accumulator = new_num_accumulator * 10 + z
                    
                    prev_digit = last_extracted_digit
                    last_extracted_digit = current_num % 10
                    current_num = current_num // 10
                    
                    if current_num == 0:
                        # Rebuild current_num with leading zeros
                        current_num = new_num_accumulator
                        
                        # Reverse the accumulated number to prepend the most significant digit (first_digit)
                        while current_num > 0:
                            reversed_num_length = reversed_num_length + 1
                            current_num = current_num // 10
                        current_num = new_num_accumulator
                        
                        num_for_reversal = current_num
                        while num_for_reversal > 0:
                            reversed_num = reversed_num * 10 + (num_for_reversal % 10)
                            num_for_reversal = num_for_reversal // 10
                        
                        current_num = first_digit
                        while reversed_num_length > 0:
                            reversed_digit = reversed_num % 10
                            reversed_num = reversed_num // 10
                            current_num = current_num * 10 + reversed_digit
                            reversed_num_length = reversed_num_length - 1

                        new_num_accumulator = 0
                        last_extracted_digit = current_num % 10
                        prev_digit = 0
                        zero_padding_count = zero_padding_count - 1
                
                # Continue the transformation process until current_num is reduced
                num2 = current_num # x2 was an unused copy
                while current_num > 100: # The condition 'x > 100' is unusual, likely meant 'while x > 10' or 'while current_num > 9'
                    if current_num != num2:
                        z = (last_extracted_digit + prev_digit) % 10
                        new_num_accumulator = new_num_accumulator * 10 + z

                    prev_digit = last_extracted_digit
                    last_extracted_digit = current_num % 10
                    current_num = current_num // 10
                    
                    if current_num == 0:
                        current_num = new_num_accumulator
                        new_num_accumulator = 0
                        last_extracted_digit = current_num % 10
                        prev_digit = 0
                        
                # Final check for the remaining two digits
                if current_num % 10 == current_num // 10 % 10:
                    is_p0_true = True
                else:
                    is_p0_true = False

            elif initial_digit_count == 0:
                all_digits_equal = True
            elif initial_digit_count == 1:
                all_digits_equal = False
                
        # 3. Handle cases where there were NO leading zeros (initial_digit_count == str_length)
        elif initial_digit_count == str_length:
            
            # Reduce the number by applying the sum-mod-10 operation repeatedly
            while initial_digit_count > 2:
                if iteration_count > 0:
                    z = (temp_digit + prev_digit) % 10
                    new_num_accumulator = new_num_accumulator * 10 + z
                
                prev_digit = temp_digit
                current_num = current_num // 10
                temp_digit = current_num % 10
                iteration_count = iteration_count + 1
                
                if current_num == 0:
                    # Reset for the next pass
                    current_num = new_num_accumulator
                    new_num_accumulator = 0
                    iteration_count = 0
                    temp_digit = current_num % 10
                    prev_digit = 0
                    num_copy = current_num
                    
                    # Recalculate length for the new number
                    initial_digit_count = 0
                    while num_copy > 0:
                        initial_digit_count = initial_digit_count + 1
                        num_copy = num_copy // 10
        
        # 4. Final check: Only two digits should remain in current_num after reduction
        if current_num % 10 == current_num // 10 % 10:
            # This is the final successful check condition in the main logic block
            return True
        else:
            # The two remaining digits are not the same
            return False

        # 5. Handle return based on leading zero checks
        # This section is largely unreachable due to the returns above, but maintained structure:
        if is_p0_true == False:
            if current_num % 10 == current_num // 10 % 10:
                return True
            else:
                return False
        else:
            return all_digits_equal
